''' 
tb_receiver.py 0.1 : Testbench for transactions with fault injection. 
  By Yngve Hafting, Alexander Wold 2022, 2024, 2025 

 The testbench 
'''
import cocotb
from cocotb import start_soon
from cocotb.clock import Clock
from cocotb.handle import Force, Freeze, Release #, setimmediatevalue
from cocotb.triggers import ClockCycles, Edge, First, FallingEdge, RisingEdge
from cocotb.triggers import ReadOnly, Timer, with_timeout, ReadWrite  
from cocotb.utils import get_sim_time
from cocotb.result import SimTimeoutError
from cocotb.queue import Queue 

from uart import UartSink, UartSource

import construct
import protocol
from pprint import pformat

import logging

import random
import numpy as np

# Conversion to pico-seconds made easy
ps_conv = {'fs': 0.001, 'ps': 1, 'ns': 1000, 'us': 1e6, 'ms':1e9}

#design constants
PERIOD_NS = 10
PWM_TIMEOUT_MS = 12
TOO_FAST_PWM_US= 143

#check_types
RESET_TYPE = "Reset"
PREAMBLE_TYPE = "Preamble error"
CHECKSUM_TYPE = "Checksum error"
MESSAGE_VALID = "Spourious message valid flag"
REPORT_ERROR = "Report error"

class MessageQueue(Queue):
    ''' Message queue is used to store and pass assertion errors with text and traceback'''
    # colouring \033[...m  see https://stackabuse.com/how-to-print-colored-text-in-python/
    
    def clear(self):
        for i in range(self.qsize()): self.get_nowait()
            
    def put_message(self, error_type, message):
        msg = (error_type, get_sim_time('ns'), message)
        self.put_nowait(msg)

    def check_queue(self, dut):
        ''' Checks that the message queue generated by assertion errors is empty'''    
        if self.empty():
            dut._log.info("\033[1;32m No errors in found!\x1b[0m")
        else:
            while not self.empty(): 
                msg = self.get_nowait()
                dut._log.info(
                    "\033[1;31mError found: {error_type}\033[0m\033[1m @{time}ns\033[0m \n{exception}".format(
                    error_type = msg[0],
                    time = msg[1],
                    exception = str(msg[2]).split('\n')[0])) #Print only first line    
            raise msg[2]  # Provide traceback for the last error reported 

    def find_error(self, dut, error_type):
        ''' Searches for a specific error in the queue and tosses the rest'''
        if self.empty():
            raise AssertionError("NO_QUEUE")
        while (self.qsize() > 0):    
            msg = self.get_nowait()
            if msg[0] == error_type:
                dut._log.info(
                    "    Found error: {error_type} @ {time}ns... ".format(
                        error_type = msg[0],
                        time = msg[1])) 
                self.clear()
                return
        #raise only if none of the queued messages are of the correct type 
        raise AssertionError("{err} error sought, but not found!".format(err=error_type))

class SignalEventMonitor():
    """ Tracks a signal's last events.  """
    def __init__(self, signal):
        self.signal = signal
        self.last_event = get_sim_time('ps')
        self.last_rise = self.last_event
        self.last_fall = self.last_event
        start_soon(self.update())
      
    async def update(self):
        while True:
            await Edge(self.signal)
            await ReadOnly()          # ReadOnly allows edge-edge measurment
            self.last_event = get_sim_time('ps')
            if self.signal == 1: self.last_rise = self.last_event
            else: self.last_fall = self.last_event
            
    def stable_interval(self, units='ps'):
        last_event_c = self.last_event/ps_conv[units]  # convert last_event to the prefix in use
        stable = get_sim_time(units) - last_event_c    # calculate stable interval
        return stable
  
class Monitor:
    """ Contains and run all checks for signals in and out of DUT """
    def __init__(self, dut, messages):
        self.dut = dut
        self.messages = messages

        start_soon(self.run())
        
    async def run(self):
        ''' start all checks '''
        await Timer(1, 'ns')   # Settle uninitialized values
        self.dut._log.info("Starting monitoring events")
        self.reset_mon = SignalEventMonitor(self.dut.rstn)

        start_soon(self.check_reset())
        start_soon(self.check_preamble())
        start_soon(self.check_checksum())
        start_soon(self.check_message_valid())
    
    async def check_reset(self):
        ''' Checks that PWM pulse (en) is deasserted when reset is applied '''
        while True:
            #await RisingEdge(self.dut.rstn)
            await FallingEdge(self.dut.rstn) 
            try:
                assert self.dut.message_valid.value == 0, "output has not been deasserted during reset"
            except AssertionError as e:
                self.messages.put_message(RESET_TYPE, e)
            self.dut._log.info("Completed: Reset test")

    async def check_preamble(self):
        ''' Checks that incorrect preamble is detected '''
        # uart has local scope as multiple is instansiated
        uart_source = UartSink(self.dut.rx, baud=115200, bits=8)
        uart_source.log.setLevel(logging.WARNING) 
        
        data = [0]*7
        i=0

        while True:
            data[i] = bytes(await uart_source.read(1))
            i = i + 1

            if 7 == i:
                
                telegram = protocol.format.parse(b''.join(data))
                self.dut._log.info("Received transaction: {}".format(pformat(telegram, width=40)))
                i=0
                try:
                    assert telegram.preamble == 0x5555, "corrupted preamble"
                except AssertionError as e:
                    self.messages.put_message(PREAMBLE_TYPE, e)
                    self.dut._log.info("Completed: Corrupt preamble test")

    async def check_checksum(self):
        ''' Checks that incorrect checksum is detected '''
        uart_source = UartSink(self.dut.rx, baud=115200, bits=8)
        uart_source.log.setLevel(logging.WARNING)
        
        i = 0
        data = [0]*7
        checksum = 0
        while True:
            data[i] = bytes(await uart_source.read(1))
            i = i + 1
            
            if 7 == i:

                telegram = protocol.format.parse(b''.join(data))
                self.dut._log.info("Received transaction: {}".format(pformat(telegram, width=40)))
                i=0
                checksum = sum(b''.join(data[0:6])) & 0xff
                try:
                    assert checksum == int.from_bytes(data[6]), "checksum mismatch"
                except AssertionError as e:
                    self.messages.put_message(CHECKSUM_TYPE, e)
                    self.dut._log.info("Completed: Checksum mismatch, received {}, expected {}".format(int.from_bytes(data[6]), checksum))

    async def check_message_valid(self):
        ''' Checks that message valid is not accepted for incorrect transactions '''
        uart_sink = UartSink(self.dut.rx, baud=115200, bits=8)
        uart_sink.log.setLevel(logging.WARNING)
        
        i = 0
        data = [0]*7
        checksum = 0
        while True:
            error = False
            
            await RisingEdge(self.dut.message_valid)
            res = uart_sink.read_nowait()

            try:
                assert len(res) == 7, "spourious message valid"
            except AssertionError as e:
                self.messages.put_message(MESSAGE_VALID, e)
                self.dut._log.info("Completed: spourious message valid")


class StimuliGenerator():
    ''' Generates all stimuli used in the ordinary tests '''
    def __init__(self, dut):
        self.dut = dut
        self.dut._log.info("Starting clock")
        start_soon(Clock(self.dut.clk, PERIOD_NS, 'ns').start())
        #self.dut.duty_cycle.value = 0
        start_soon(self.reset_module())

    async def reset_module(self):
        self.dut._log.info("Resetting module... ")
        self.dut.rstn.value = 0
        await Timer(15, 'ns')
        self.dut.rstn.value = 1
        
    async def run(self):
        self.dut._log.info("Starting duty cycle tests ")

        uart_source = UartSource(self.dut.rx, baud=115200, bits=8)
        uart_source.log.setLevel(logging.WARNING)

        dgram = b'\x55\x55\x02\x0f\x04\xff'
        checksum = int.to_bytes(sum(dgram) & 0xff)
                
        await uart_source.write(dgram+checksum)
        await uart_source.wait() 

# FIAT-testing
@cocotb.test()
async def fiat_sequencer(dut):
    ''' Starts monitoring tasks and stimuli generators '''
    messages = MessageQueue()
    fiatStimuli = StimuliGenerator(dut) 
    fiatMonitor = Monitor(dut, messages)
    fiat = FaultInjector(dut, messages)      
    # Inject Faults to check that the testbench responds to faults
    await fiat.run()


# Ordinary testing
@cocotb.test()
async def test_sequencer(dut):
    ''' Starts monitoring tasks and stimuli generators '''
    messages = MessageQueue()
    stimuli = StimuliGenerator(dut)
    monitor = Monitor(dut, messages)
    dut._log.info("*** STARTING ORDINARY TESTS ***")
    await stimuli.run()  
    messages.check_queue(dut)
    dut._log.info("*** ORDINARY TESTS DONE! ***")

    
class FaultInjector():
    """ Contain tests to verify that each assertion will trigger """
    def __init__(self, dut, messages):
        self.dut = dut
        self.messages = messages
        
    async def run(self):
        ''' run all FIAT tests '''
        self.dut._log.info("*** FAULT INJECTION RUNNING ***")
        #print(self.dut.transaction_encoder_inst.state) #.value = Force(0)
        # To test ordinary reporting: change <fault>_TYPE to REPORT_ERROR in the list 
        # To test non-reported error, use "not reported" as error type 
        fiat_methods = [
            (self.reset(), RESET_TYPE),
            (self.incorrect_preamble(), PREAMBLE_TYPE),
            (self.incorrect_checksum(), CHECKSUM_TYPE),
            (self.message_valid(), MESSAGE_VALID)
            ]
        
        for each in fiat_methods:
            await each[0]
            self.release()            
            if each[1] != REPORT_ERROR: 
                self.messages.find_error(self.dut, each[1])
            else: 
                self.messages.check_queue(self.dut) 
        self.dut._log.info("\x1b[1;32m Injected faults managed! \x1b[0m")
        await RisingEdge(self.dut.clk) # Required to finish gracefully
        self.dut._log.info("*** FAULT INJECTION COMPLETE ***")
        
    def release(self):  
        ''' Releases all Forced values. 
              Simulators may treat release differently:
              GHDL5.0.1 will let DUT-inputs become 'U' when released; they will not maintain value.
              GHDL5.0.1 require an write-event or immediate assignment for relase to work.
              We use immediate release to allow running without further events scheduled.  
        '''
        # Store input values
        reset = self.dut.rstn.value
        message_valid = self.dut.message_valid.value
        
        self.dut.rstn.setimmediatevalue(Release())  
        self.dut.message_valid.setimmediatevalue(Release())
        
        # Ensure DUT-input has value
        self.dut.rstn.setimmediatevalue(reset)
        self.dut.message_valid.setimmediatevalue(message_valid)
        
    async def disable_reset(self):
        self.dut.rstn.value = Force(0)
        await Timer(20, 'ns')
   
    async def reset(self):
        ''' Enable asserted while reset is deasserted'''
        await RisingEdge(self.dut.clk)
        self.dut._log.info("Injecting error: Enable during reset...")
        self.dut.rstn.value = Force(1)
        self.dut.message_valid.value = Force(1)
        await RisingEdge(self.dut.clk)
        self.dut.rstn.value = Force(0)
        await RisingEdge(self.dut.clk)

    async def message_valid(self):
        await RisingEdge(self.dut.clk)
        self.dut._log.info("Injecting error: Message error...")
    
    async def incorrect_preamble(self):
        self.dut._log.info("Injecting error: incorrect preamble...")
        """
        first send a packet with incorrect preamble
        """
        uart_source = UartSource(self.dut.rx, baud=115200, bits=8)
        uart_source.log.setLevel(logging.WARNING)

        #send incorrect preamble but correct checksum
        # flip random bit in preamble
        dgram = bytearray(b'\x55\x55\x02\x0f\x04\xff')
        byte_index = random.randint(0, 1)
        bit_index = random.randint(0, 7)
        dgram[byte_index] ^= 1 << bit_index
        
        checksum = int.to_bytes(sum(dgram) & 0xff)

        await uart_source.write(dgram+checksum)
        await uart_source.wait() # https://github.com/alexforencich/cocotbext-uart/issues/1#issue-804852632

        self.dut.message_valid.value = Force(1)
        await FallingEdge(self.dut.clk)
        self.dut.message_valid.value = Release()
                
    async def incorrect_checksum(self):
        self.dut._log.info("Injecting error: incorrect preamble...")
        """
        first send a packet with incorrect preamble
        """
        uart_source = UartSource(self.dut.rx, baud=115200, bits=8)
        uart_source.log.setLevel(logging.WARNING)

        #send incorrect preamble but correct checksum
        # flip random bit in preamble
        dgram = bytearray(b'\x55\x55\x02\x0f\x04\xff')
        checksum = int.to_bytes(sum(dgram) & 0xff)

        dgram = dgram+checksum
        
        byte_index = random.randint(2, 6)
        bit_index = random.randint(0, 7)
        dgram[byte_index] ^= 1 << bit_index

        await uart_source.write(dgram)
        await uart_source.wait()

        self.dut.message_valid.value = Force(1)
        await FallingEdge(self.dut.clk)
        self.dut.message_valid.value = Release()
        
